1
12/16/2022

# Use react-query as a data fetching solution

## Context and Problem Statement

VRAI frontends need a consistent pattern to fetch data. Next.js, given our use case, presents us with a unique problem:

- Many pages in `vno-site` have herculean data requirements that not only block the page from beginning to render,
  but the data also doesn't have an API underneath it. So many of our routes have to:

  1.  _fetch_ all that data,
  2.  _transform_ it in expensive operations, after which it's finally
  3.  _dispatched_ into global state (redux).
  4.  Components then consume that data using selectors we are responsible for.
      One good example of the complexity this introduces is our need for [memoized selectors](https://redux.js.org/usage/deriving-data-selectors#optimizing-selectors-with-memoization) on some pages.

- Some of the key pain points with this approach are:
  - We have to maintain that redux layer that's dispatching/selecting that data.
  - Said redux layer has become unmaintainable. There aren't any easy ways for us to see/manipulate/validate that data on our own,
    even moreso when compared to more modern solutions that manage this cache/store layer out of the box.
  - There is so much 'extra' data fetched in so many places that redux-devtools often freezes/breaks on the larger keys (at times
    containing many thousands of product variants)
  - These huge blobs of data block page renders and only become more difficult to work with as we implement features that diverge
    this pattern from itself many times over.

---

So we must address the question:
\*\*Is there a way to have Next.js declaratively fetch "required" page data on the server, then deliver that data to the frontend in a predictable, reliable way?

#### What we need is cohesion between fetching the "required" data on the server and whatever happens when the client picks up.

This feels unwieldy because we're effectively trying to manage one state object across the two machines as a sequence occurs.
Ideally, frontend components have ownership over their own data/query.
Components shouldn't have to implement logic to figure out _if_ the data it wants is in the store/cache.
A component should only have to know **what data it wants**, and in the case of SWR or react-query that is
as simple as knowing **what key that data is stored under in the cache.** If it's not there, `queryFn` will go get it.

## Considered Options

- [relay](https://relay.dev/)
- [swr](https://swr.vercel.app/docs/)
- [react-query](https://tanstack.com/query/v4/docs/)

## Decision Outcome

`react-query` shines here. while `swr` similarly handles batching/caching/deduping/revalidating,
it does not offer any concepts to deal with serverside data requirements. Since our goal is to allow GSSP to "segue" right into clientside data operations as seamlessly as possible, `react-query`'s providing of a serverside `QueryClient`, the `initialData` property, as well as the `hydrate()` and `dehydrate()` API, we have a relatively durable solution out of the box.

in short,

## `react-query` allows us to fetch as much or as little data as we want on the server, pass that data to `_app.js` and from there have every component ask, using cache keys, for the data it needs. If the data was passed in as props, great - we can even revalidate it here if we need to. If the data was _not_ prefetched on the server, `queryFn` will fetch it clientside and the library handles storing, caching, and revalidating that data for us - no global state for us to manage, no dispatchers or memoized selector functions needed.
